#!/usr/bin/env python

import sys  # receive path as argument
import os   # iterate over this path

# filter only .txt files
def is_behavior(beh):
    if ".txt" in beh:
        return True
    return False

# load behaviors from the given paths
def load_behaviors(beh_path):
    # dict of behaviors
    behaviors=dict()
    # list path
    for beh in os.listdir(beh_path):
        # get only behavior files
        if is_behavior(beh):
            # clear function list for this behavior
            func_list=[]
            # debug print
            if __debug__:
                print(beh)
            # for functions inside the given behavior file
            for func in open(beh_path+"/"+beh,"r"):
                # debug print
                if __debug__:
                    print(func.strip())
                # insert function in behavior list
                func_list.append(func.strip())
            # add function list to behavior dict entry
            behaviors[beh]=func_list
    # return the behavior dict
    return behaviors

# given a function, return its behavior class
def func_to_behavior(behaviors,function):
    # for each behavior class
    for beh in behaviors:
        # for each function within a behavior class
        for func in behaviors[beh]:
            # if the given function is inside
            if func == function:
                # return the behavior (without file extension)
                return beh.replace(".txt","")
    # case no behavior found
    return "Unknown"

# display usage message
def usage(bin_name):
    print("Usage: python %s <behaviors_path> <functions_file>" % bin_name)

# parse arguments
def parse(bin_name,args):
    # accept only the two required arguments
    if(len(args)!=2):
        # case not, display usage message
        usage(bin_name)
        # and quit
        sys.exit(0)
    # case two supplied, return the two parms
    return args[0],args[1]

# return a list of functions from a given file
def get_functions_from_file(func_file):
        # open file, read content, clean control chars, split by lines
	f = open(func_file,"r").read().strip().split("\n")
	return f

# Main itself
def main(beh_path,func_file):
    # load behaviors
    behavior=load_behaviors(beh_path)
    # load functions
    functions = get_functions_from_file(func_file)
    #get behavior for each function
    for func in functions:
    	beh=func_to_behavior(behavior,func)
        print(beh)

# Entry Point

# Check who is calling
# By now, only direct calls are supported

if __name__ == '__main__':

        # start parsing args
        beh_path,func_file=parse(sys.argv[0],sys.argv[1:])

        # if ok, call main
        main(beh_path,func_file)

else:
        # Not Supported. Working on it.
        print("Module import not supported yet!")
        #So, exiting
        sys.exit(0)
